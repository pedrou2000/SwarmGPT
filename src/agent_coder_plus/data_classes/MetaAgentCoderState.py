import os, sys
sys.path.append(os.path.abspath(__file__))
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from langchain_core.pydantic_v1 import BaseModel, Field
import operator 
from typing import Annotated, List, Optional

import constants

class MetaAgentCoderState():
    incomplete_method: Annotated[str, Field(description="Incomplete method to be completed")]
    generated_tests: Annotated[str, Field(description="Generated tests for the method")]
    completed_method: Annotated[str, Field(description="Completed method")]
    tests_passed: Annotated[bool, Field(description="Whether the tests passed or not in the generated code")]
    feedback: Annotated[str, Field(description="Feedback from the tests run on the generated code")]
    current_iterations: Annotated[int, Field(description="Current number of iterations in the refinement looop")]
    max_iterations: Annotated[int, Field(description="Maximum number of iterations in the refinement loop")]
    passed_tests_threshold: Annotated[float, Field(description="Threshold for the proportion of tests that need to pass")]
    refine_else_restart: Annotated[bool, Field(description="Whether to refine the method, restart or continue")]

    # Meta Architecture Variables
    current_meta_iterations: Annotated[int, Field(description="Current number of iterations in the meta architecture loop")]
    n_multi_agent_iterations: Annotated[int, Field(description="Number of iterations in the meta architecture loop")]
    multi_agent_completed: Annotated[bool, Field(description="Whether the multi-agent loop has been completed")]
    final_answers: Annotated[dict, Field(description="All of the final answers generated by the agents in dictionary form")]
    final_answer: Annotated[str, Field(description="The final answer generated by the meta multiagent system")]


    def __init__(
            self, 
            incomplete_method: str = None, 
            generated_tests: str = None, 
            completed_method: str = None, 
            tests_passed: bool = False,
            feedback: str = None,
            current_iterations: int = -1,
            max_iterations: int = -1,
            passed_tests_threshold: float = -1, 
            refine_else_restart: bool = None,
            current_meta_iterations: int = -1,
            n_multi_agent_iterations: int = -1,
            multi_agent_completed: Optional[bool] = None,
            final_answers: Optional[dict] = None,
            final_answer: Optional[str] = None
        ):
        if incomplete_method is not None:
            self.incomplete_method = incomplete_method
        if generated_tests is not None:
            self.generated_tests = generated_tests
        if completed_method is not None:
            self.completed_method = completed_method
        if tests_passed is not None:
            self.tests_passed = tests_passed
        if feedback is not None:
            self.feedback = feedback
        if current_iterations != -1:
            self.current_iterations = current_iterations
        if max_iterations != -1:
            self.max_iterations = max_iterations
        if passed_tests_threshold != -1:
            self.passed_tests_threshold = passed_tests_threshold
        if current_meta_iterations != -1:
            self.current_meta_iterations = current_meta_iterations
        if n_multi_agent_iterations != -1:
            self.n_multi_agent_iterations = n_multi_agent_iterations
        if multi_agent_completed is not None:
            self.multi_agent_completed = multi_agent_completed
        if final_answers is not None:
            self.final_answers = final_answers
        if final_answer is not None:
            self.final_answer = final_answer

    
    def clean_state(self) -> 'MetaAgentCoderState':
        self.completed_method = None
        self.tests_passed = False
        self.feedback = None
        self.current_iterations = 0
        return self
    
    def __str__(self) -> str:
        return f"AgentCoder State with incomplete method: {self.incomplete_method}"

if __name__ == "__main__":
    macm_state = MetaAgentCoderState(incomplete_method='def some_method():\n')
    print(macm_state)
